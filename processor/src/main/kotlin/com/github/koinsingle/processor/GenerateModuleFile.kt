package com.github.koinsingle.processor

import com.github.koinsingle.annotation.Single
import com.github.koinsingle.processor.extensions.error
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.TypeSpec
import java.io.File
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.element.Element
import javax.lang.model.element.ElementKind
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.Modifier
import javax.lang.model.element.VariableElement

class GenerateModuleFile(
        private val processingEnv: ProcessingEnvironment
) {

    companion object {
        const val KAPT_KOTLIN_GENERATED_OPTION_NAME = "kapt.kotlin.generated"
    }

    fun generate(elements: List<Element>) {

        if (elements.isEmpty()) return

        val kaptKotlinGeneratedDir = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME]

        val generatedClassName = "AutoGeneratedModule"
        val generatedPackageName = "com.github.koinsingle.modules"

        val module = ClassName("org.koin.dsl", "module")

        val generatedModules = FunSpec.builder("generatedModules")
                .beginControlFlow("return %T", module)

        elements.forEach {
            try {
                addSingle(generatedModules, it)
            } catch (ex: ProcessingException) {
                processingEnv.error(ex.element, ex.message)
            }
        }

        generatedModules
                .endControlFlow()

        val file = FileSpec.builder(generatedPackageName, generatedClassName)
                .addType(
                        TypeSpec.classBuilder(generatedClassName)
                                .addFunction(
                                        generatedModules.build())
                                .build()
                )
                .build()

        file.writeTo(File(kaptKotlinGeneratedDir))
    }

    private fun addSingle(generatedModulesBuilder: FunSpec.Builder, annotatedElement: Element) {

        val constructorElement = annotatedElement.enclosedElements.firstOrNull {
            it.kind == ElementKind.CONSTRUCTOR &&
                    it.modifiers.contains(Modifier.PUBLIC)
        } ?: throw ProcessingException(
                annotatedElement,
                "The class ${annotatedElement.simpleName} annotated with ${Single::class.simpleName} " +
                        "must have a public constructor"
        )

        val constructor = constructorElement as ExecutableElement

        val constructorParameters = constructor.parameters.joinToString(
                separator = ",",
                prefix = " "
        ) {
            generateConstructorParameter(it).plus(" ")
        }

        val single = "single { %T($constructorParameters) }"
        generatedModulesBuilder.addStatement(single, annotatedElement)
    }

    private fun generateConstructorParameter(parameter: VariableElement): String = "get()"
}